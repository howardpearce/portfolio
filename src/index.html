<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Portfolio</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <script src="https://kit.fontawesome.com/4305f7f018.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.144.0/three.min.js"></script>
  <script>
    // Dot animation acts weird if you resize the window. Refreshing fixes it.
    window.onresize = function(event) { document.location.reload(true); }
  </script>
  <script>
    // Cannot start until HTML has been rendered
    document.addEventListener("DOMContentLoaded", function () {
      // container for animation
      const canvas = document.querySelector("#hero-graphic");
      var width = canvas.clientWidth;
      var height = canvas.clientHeight;

      // constants
      const CIRCLE_SPEED = 0.1;
      const DRIFT_SPEED = 0.05;
      const GUARD = 0.05;

      // global variables
      var waveCenterX = 0;
      var waveCenterY = 0;
      var radius = 0.1;
      var particleCount = 100000;
      // the original position of every particle in the array
      const originalParticlePosition = new Float32Array(particleCount * 3);
      // the current position (after being moved)
      var currentParticlePosition = new Float32Array(particleCount * 3);
      const bufferGeometry = new THREE.BufferGeometry();

      // grab CSS variables for color and convert them to usable hex
      var bodyStyle = getComputedStyle(document.body);
      var dotColor = bodyStyle.getPropertyValue("--primary-color");
      var backgroundColor = bodyStyle.getPropertyValue("--bg-color");
      dotColor = parseInt(dotColor.trim().replace("#", ''), 16);
      backgroundColor = parseInt(backgroundColor.trim().replace("#", ''), 16);

      // set up scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(90, width / height, 0.1, 9999 );
      const renderer = new THREE.WebGLRenderer();

      configureScene();
      createParticleArray();
      addLighting();

      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });

      animate();

      /* FUNCTION DECLARATIONS DOWN BELOW ------------------------------------------------------------- */

      function createParticleArray() {
        // initialize array of dots
        const material = new THREE.PointsMaterial( { size: 0.0, color: dotColor } );

        // populate array with values (create a rectangular grid)
        setParticlePositions();

        bufferGeometry.setAttribute('position', new THREE.BufferAttribute(currentParticlePosition, 3));
        bufferGeometry.dynamic = true;
        var particlesMesh = new THREE.Points(bufferGeometry, material);
        scene.add(particlesMesh);
      }

      function configureScene() {
        scene.background = new THREE.Color(backgroundColor);
        renderer.setSize(width, height);
        canvas.appendChild(renderer.domElement);
      }

      function setParticlePositions() {
        var x = -25;
        var y = 5;
        var z = -5;
        // for every particle, set its position
        for (let i = 0; i < particleCount * 3; i+=3) {
          currentParticlePosition[i] = x;
          currentParticlePosition[i+1] = y;
          currentParticlePosition[i+2] = z;
          originalParticlePosition[i] = x;
          originalParticlePosition[i+1] = y;
          originalParticlePosition[i+2] = z;
          // wrap around at end of line
          if (x > 25) {
            x = -25;
            y -= 0.1;
          } else {
            x+=0.1;
          }
        }
      }

      function addLighting() {
        var light1 = new THREE.PointLight(0xFFFFFF);
        light1.position.x = 0;
        light1.position.y = 0;
        light1.position.z = 0;
        scene.add(light1);
      }

      function distanceFromCenter(x, y) {
        return Math.sqrt(Math.pow(x - waveCenterX, 2) + Math.pow(y - waveCenterY, 2));
      }

      function driftToOrigin(diff, index, position) {
        if (Math.abs(diff) > GUARD) {
          if (diff < 0) {
            position[index] -= DRIFT_SPEED;
          } else {
            position[index] += DRIFT_SPEED;
          }
        } else {
          position[index] = originalParticlePosition[index];
        }
      }

      function animateParticles() {
        for (let i = 0; i < particleCount * 3; i+=3) {
          var currentPosition = bufferGeometry.attributes.position.array;
          // calculate the difference between its origin and current location in all 3 dimensions
          var diffX = originalParticlePosition[i] - currentPosition[i];
          var diffY = originalParticlePosition[i+1] - currentPosition[i+1];
          var diffZ = originalParticlePosition[i+2] - currentPosition[i+2];
          driftToOrigin(diffX, i, currentPosition);
          driftToOrigin(diffY, i+1, currentPosition);
          driftToOrigin(diffZ, i+2, currentPosition);
        }
        bufferGeometry.attributes.position.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame( animate );
        radius += CIRCLE_SPEED;
        var currentPosition = bufferGeometry.attributes.position.array;

        for (let i = 0; i < particleCount * 3; i+=3) {
          var distance = distanceFromCenter(currentPosition[i], currentPosition[i+1]);
          var normalizedDistance = radius - distance;
          if ( Math.abs(normalizedDistance) < 0.8 ) {
            currentPosition[i+2] = originalParticlePosition[i+2] + (Math.cos(normalizedDistance * 2) / 2);
          }
        }

        if (radius > 40) {
          radius = 0.1;
          waveCenterX = (Math.random() - 0.5) * 40;
          waveCenterY = (Math.random() - 0.5) * 15;
        }

        animateParticles();
        bufferGeometry.attributes.position.needsUpdate = true;
      }

    });
  </script>
</head>
<body style="margin: 0px;">
  <app-root></app-root>
</body>
</html>
